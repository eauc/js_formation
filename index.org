#+TITLE: Formation Javascript
#+AUTHOR: Emmanuel Auclair
#+OPTIONS: toc:1
#+OPTIONS: reveal_center:t reveal_width:1200 reveal_height:800
#+REVEAL_HLEVEL: 2
#+REVEAL_ROOT: ./reveal.js
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_DEFAULT_FRAG_STYLE: appear
#+REVEAL_EXTRA_CSS: ./local.css

* Presentation & History
  #+INCLUDE: "./slides/presentation.org"

* Types
  #+INCLUDE: "./slides/types.org"

* Variables
  #+INCLUDE: "./slides/vars.org"

* Functions
    Creation:
    #+BEGIN_SRC js :exports code :results output :session function-types
    function myFunction() {
      console.log("This is my function !");
    }
    #+END_SRC

    #+BEGIN_SRC js :exports results :results output :session function-types
    myFunction();
    #+END_SRC

    #+BEGIN_NOTES
    - can have names
    #+END_NOTES

    #+REVEAL: split

    Arguments and return value:
    #+BEGIN_SRC js :exports code :results output :session function-types
    function myAdd(a, b) {
      return a + b;
    };
    #+END_SRC

    #+BEGIN_SRC js :exports results :results output :session function-types
    myAdd("hello ", "world");
    myAdd("hello ");
    #+END_SRC

    #+BEGIN_SRC js :exports results :results output :session function-types
    myAdd.length;
    #+END_SRC

    #+BEGIN_NOTES
    - can have arguments and return values
    - no check on arguments number when called - args are undefined !
    #+END_NOTES
** Arguments
   TODO: passed by reference, arity fn.length, extra/missing args, arguments value
   args manipulation tricks, variable args
** Hoisting
   TODO: function are hoisted and that's great
** Closure

   #+REVEAL: split

   Functions can reference variables declared in parent scopes.
   #+BEGIN_SRC js :exports code :results output :session vars-local-scope
   function myFunction() {
     var myClosedVar = "hello, world";

     return function myClosure() {
       return myClosedVar;
     };
   }
   var func = myFunction();
   #+END_SRC

   #+BEGIN_SRC js :exports results :results output :session vars-local-scope
   func();
   #+END_SRC

   #+BEGIN_NOTES
   - functions that reference outside variables are called "closures".
   - that's how you implement private scope in JS.
   - that's how you implement memory leaks in JS :P
   #+END_NOTES

   #+REVEAL: split

   That's how you implement private scope in Js.
   #+BEGIN_SRC js :exports code :results output :session vars-local-scope
   function createCounter() {
     var count = 0;

     return function() {
       return ++count;
     };
   }
   var myCounter = createCounter();
   #+END_SRC

   #+BEGIN_SRC js :exports results :results output :session vars-local-scope
   myCounter();
   myCounter();
   #+END_SRC
    TODO: how it works, memory leak, comparison with thread stack
** High order functions
   TODO: callbacks args, closures return, functionnal algorithms
** this
   TODO: this keyword overview, default=global=window, object-method call
   var me = this horror show on callbacks
** apply & call
   TODO: differences & when to use, args manipulation, this manipulation
** ES6: arrow functions
   TODO: possible syntaxes, this difference, use everywhere
** ES6: arguments spread
   TODO: variable arguments, args manipulation
** ES6: arguments destructuring
   TODO: how can I speak of this here without first speaking of arrays ?
* Arrays
    Get:
    #+BEGIN_SRC js :exports results :results output :session array-types
    myArray[0];
    myArray[2];
    #+END_SRC

    beyond last item:
    #+BEGIN_SRC js :exports results :results output :session array-types
    myArray[3];
    #+END_SRC

    #+BEGIN_NOTES
    - arrays can contain different types
    - accessing entries beyond the end returns undefined
    - setting entries beyond the end returns sparse arrays
    #+END_NOTES

    Set:
    #+BEGIN_SRC js :exports results :results output :session array-types
    myArray[1] = null;
    myArray;
    #+END_SRC

    beyond last item:
    #+BEGIN_SRC js :exports results :results output :session array-types
    myArray[5] = 5;
    myArray;
    #+END_SRC
** Methods
   TODO: basic methods (splice, slice, length, push, pop, concat...)
   for(var in array)
*** Array Equality
** High order methods
   TODO: filter, map, reduce
** Typed Arrays
   TODO: UInt8Array etc
** ES6: destructuring
   TODO: introduce destructuring, compare with ES5 code
** ES6: spread
   TODO: introduce array manipulations with spread
   talk about immutability ?
* Objects
** Properties
    Properties:
    #+BEGIN_SRC js :exports code :results output :session object-types
    var myObject = {
      a: 0,
      1: "1",
      null: 2,
    };
    #+END_SRC

    List entries:
    #+BEGIN_SRC js :exports results :results output :session object-types
    Object.keys(myObject);
    Object.values(myObject);
    #+END_SRC

    #+REVEAL: split

    Get:
    #+BEGIN_SRC js :exports results :results output :session object-types
    myObject.a;
    myObject[1];
    myObject[null];
    #+END_SRC

    #+REVEAL: split

    Set:
    #+BEGIN_SRC js :exports results :results output :session object-types
    myObject.b = 3;
    myObject[true] = 4;
    myObject[undefined] = 5;
    #+END_SRC

    #+BEGIN_SRC js :exports results :results output :session object-types
    Object.keys(myObject);
    Object.values(myObject);
    #+END_SRC

    #+BEGIN_SRC js :exports results :results output :session object-types
    myObject["b"];
    myObject[true];
    myObject[undefined];
    #+END_SRC

    #+REVEAL: split

    Keys are cast to Strings:
    #+BEGIN_SRC js :exports results :results output :session object-types
    myObject[{toto: 1}] = 5;
    myObject[[1,2,3]] = 6;
    #+END_SRC

    #+BEGIN_SRC js :exports results :results output :session object-types
    Object.keys(myObject);
    Object.values(myObject);
    #+END_SRC

    #+BEGIN_SRC js :exports results :results output :session object-types
    myObject[{toto: 42}];
    myObject[[1,2,3]];
    #+END_SRC

    #+BEGIN_NOTES
    - you can add keys after creation
    - keys are always cast to strings - so you better know your casts if you're writting this shit
    - seriously, don't do this
    #+END_NOTES
*** Getting/Setting
    TODO: ["prop"] .prop, dynamique
    impact on performances
*** Deleting
    TODO: delete, = undefined
    impact on performances
*** Methods
    TODO: invoke, consequences on this
*** Object Equality
** ES6: properties shortcut
** Prototype
   TODO: explain prototype chain
   hasOwnProperty, for(var in object)
** new & Contructor functions
   TODO: explain how it works, traditionnal pattern
   impact on performances
** ES6: Object.create
   TODO: easy prototype pattern
** ES6: classes
   TODO: for OOP fans, not hoisted :(
** ES7: spread
   TODO: introduce objects merge with spread
   talk about immutability ?
* Asynchronocity
** Execution model
   TODO: single threaded, asynchronous
   Tasks, micro-tasks ?
** Exceptions
   TODO: try/catch
** Callbacks
   TODO: standard Node form, callback hell, pyramid of doom
** setTimeout/setInterval
** ES6: Promises
   TODO: why, how it works
   advantages & inconvenients (spread like a virus)
** ES7: async/await
   TODO: how it works, inconvenients (spread like a virus)
* Tools
** NPM
** Yarn
** Eslint
** Babel
** Webpack
** Chrome debugger
* Misc
** Node
** ES6/7/Node modules
** Date
** Lodash
** Immutability
